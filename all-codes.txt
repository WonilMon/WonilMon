===== C:\Users\so0002\Downloads\bandhand\bandhand\.gitignore =====
node_modules
.expo
.expo-shared
.env
.DS_Store


===== C:\Users\so0002\Downloads\bandhand\bandhand\app.config.js =====
// app.config.js

export default {
  expo: {
    name: 'BandHand',
    slug: 'bandhand-app',
    version: '1.0.0',
    sdkVersion: '53.0.0',
    extra: {
    },
    ios: {
      infoPlist: {
        NSPhotoLibraryUsageDescription:
          'プロフィール画像を選択するためにフォトライブラリへのアクセスが必要です。',
      },
    },
  },
};


===== C:\Users\so0002\Downloads\bandhand\bandhand\App.js =====
// App.js
import React from 'react';
import RootNavigator from './src/navigation/AuthStack';

export default function App() {
  return <RootNavigator />;
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\app.json =====
{
  "expo": {
    "name": "bandhand",
    "slug": "snack-164f8f59-1ff8-48f5-b109-ae8ba0d00cda",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "newArchEnabled": true,
    "splash": {
      "image": "./assets/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "edgeToEdgeEnabled": true
    },
    "web": {
      "favicon": "./assets/favicon.png"
    }
  }
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\index.js =====
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);


===== C:\Users\so0002\Downloads\bandhand\bandhand\package.json =====
{
  "license": "0BSD",
  "main": "index.js",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "expo": "~53.0.12",
    "expo-status-bar": "~2.2.3",
    "react": "19.0.0",
    "react-native": "0.79.4",
    "@react-native-async-storage/async-storage": "2.1.2",
    "@react-native-community/datetimepicker": "8.3.0",
    "@react-native-picker/picker": "2.11.0",
    "@react-navigation/drawer": "^7.4.1",
    "@react-navigation/native": "^7.1.10",
    "@react-navigation/native-stack": "^7.3.14",
    "@react-navigation/stack": "^7.3.3",
    "@supabase/supabase-js": "^2.49.9",
    "date-fns": "*",
    "expo-image-picker": "~16.1.4",
    "react-native-gesture-handler": "~2.24.0",
    "react-native-modal-datetime-picker": "^18.0.0",
    "react-native-picker-select": "^9.3.1",
    "react-native-reanimated": "~3.17.4",
    "react-native-safe-area-context": "5.4.0",
    "react-native-screens": "~4.11.1",
    "react-native-vector-icons": "*",
    "zustand": "^5.0.5",
    "expo-constants": "~17.1.6",
    "immer": "9.0.21",
    "@types/react": "18.2.47",
    "use-sync-external-store": "1.2.0"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0"
  },
  "private": true
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\api\auth.js =====
// src/api/auth.js
import { supabase } from './supabaseClient';

export async function signUp(email, password) {
  const { data, error } = await supabase.auth.signUp({ email, password });
  return { data, error };
}

export async function signIn(email, password) {
  try {
    console.log('📩 Signing in with:', email, password);

    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password,
    });

    console.log('📬 signIn result data:', data);
    console.log('📬 signIn result error:', error);

    return { data, error };
  } catch (err) {
    console.log('❌ signIn exception:', err);
    return { data: null, error: err };
  }
}

export async function signOut() {
  const { error } = await supabase.auth.signOut();
  return { error };
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\api\comments.js =====
// src/api/comments.js
import { supabase } from './supabaseClient';

export const fetchCommentsForUser = async (toUserId) => {
  const { data, error } = await supabase
    .from('comments')
    .select('*, from_user_id(*)')
    .eq('to_user_id', toUserId)
    .order('created_at', { ascending: false });

  if (error) throw error;
  return data;
};

export const postComment = async (fromUserId, toUserId, content) => {
  const { data, error } = await supabase.from('comments').insert([
    {
      from_user_id: fromUserId,
      to_user_id: toUserId,
      content,
    },
  ]);

  if (error) throw error;
  return data;
};


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\api\supabaseClient.js =====
// src/api/supabaseClient.js

// import { createClient } from '@supabase/supabase-js';
// import Constants from 'expo-constants';

// const { SUPABASE_URL, SUPABASE_ANON_KEY } = Constants.expoConfig.extra;

// console.log('✅ SUPABASE_URL:', SUPABASE_URL);

// export const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

import { createClient } from '@supabase/supabase-js';
import Constants from 'expo-constants';


const supabaseUrl = "//";
const supabaseAnonKey = "//";


export const supabase = createClient(supabaseUrl, supabaseAnonKey);


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\components\forms\CheckBoxGroup.js =====
// src/components/common/CheckBoxGroup.js
import React from 'react';
import { View, Text, TouchableOpacity } from 'react-native';

export default function CheckBoxGroup({
  label,
  options = [],
  selected = [],
  onChange,
  singleSelect = false,
}) {
  const toggleOption = (item) => {
    if (singleSelect) {
      onChange([item]);
    } else {
      onChange(
        selected.includes(item)
          ? selected.filter((val) => val !== item)
          : [...selected, item],
      );
    }
  };

  return (
    <View >
      <Text >{label}</Text>
      <View >
        {options.map((item) => (
          <TouchableOpacity
            key={item}
            onPress={() => toggleOption(item)}
           
          >
            <Text
             
            >
              {item}
            </Text>
          </TouchableOpacity>
        ))}
      </View>
    </View>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\components\forms\CommentList.js =====
// src/components/common/CommentList.js
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  Image,
} from 'react-native';
import { supabase } from '../../api/supabaseClient';
import { useAuthStore } from '../../store/useAuthStore';
import { format } from 'date-fns';

export default function CommentList({ to_user_id }) {
  const user = useAuthStore((state) => state.user);
  const [comments, setComments] = useState([]);
  const [newComment, setNewComment] = useState('');
  const [limit, setLimit] = useState(10);

  useEffect(() => {
    fetchComments();
  }, [limit]);

  const fetchComments = async () => {
    const { data } = await supabase
      .from('comments')
      .select('*, from_user_id!inner(nickname, avatar_url)')
      .eq('to_user_id', to_user_id)
      .order('created_at', { ascending: false })
      .limit(limit);
    if (data) setComments(data);
  };

  const handleSubmit = async () => {
    if (!newComment.trim()) return;

    const { data: inserted, error } = await supabase
      .from('comments')
      .insert({
        from_user_id: user.id,
        to_user_id,
        content: newComment,
      })
      .select()
      .single();

    if (!error && inserted) {
      await supabase.from('notifications').insert({
        user_id: to_user_id,
        type: 'comment',
        reference_id: inserted.id,
      });
      setNewComment('');
      fetchComments();
    }
  };

  return (
    <View >
      <Text >💬 コメント</Text>
      {comments.length === 0 && (
        <Text >まだコメントがありません</Text>
      )}
      {comments.map((c) => (
        <View key={c.id} >
          <View>
            <Image
              source={{ uri: c.from_user_id.avatar_url }}
            
            />
            <Text>{c.from_user_id.nickname}</Text>
            <Text>
              {format(new Date(c.created_at), 'yyyy/MM/dd HH:mm')}
            </Text>
          </View>
          <Text>{c.content}</Text>
        </View>
      ))}

      {comments.length >= limit && (
        <TouchableOpacity onPress={() => setLimit((prev) => prev + 10)}>
          <Text>さらに表示</Text>
        </TouchableOpacity>
      )}

      {/* 댓글 입력 */}
      <View>
        <TextInput
          style={styles.input}
          placeholder="コメントを入力..."
          value={newComment}
          onChangeText={setNewComment}
        />
        <TouchableOpacity onPress={handleSubmit}>
          <Text style={styles.send}>投稿</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\components\forms\DropdownSelector.js =====
// src/components/common/DropdownSelector.js
import React from 'react';
import { View, Text } from 'react-native';
import { Picker } from '@react-native-picker/picker';

export default function DropdownSelector({
  label,
  options = [],
  selected,
  onSelect,
}) {
  return (
    <View >
      <Text >{label}</Text>
      <View >
        <Picker
          selectedValue={selected}
          onValueChange={(itemValue) => onSelect(itemValue)}
        >
          <Picker.Item label="選択してください" value="" />
          {options.map((option) => (
            <Picker.Item key={option} label={option} value={option} />
          ))}
        </Picker>
      </View>
    </View>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\components\forms\UserFilterBar.js =====
import React from 'react';
import {
  View,
  Text,
  TextInput,
  Picker,
  TouchableOpacity,
} from 'react-native';

const REGIONS = ['すべて', '東京', '大阪', '名古屋', '福岡'];
const PARTS = ['ボーカル', 'ギター', 'ベース', 'ドラム', 'キーボード'];

export default function UserFilterBar({
  sortBy,
  setSortBy,
  region,
  setRegion,
  minAge,
  maxAge,
  setMinAge,
  setMaxAge,
  partFilter,
  setPartFilter,
}) {
  return (
    <View>
      <View >
        <Text>並び替え:</Text>
        <TouchableOpacity
          onPress={() => setSortBy('name')}
        >
          <Text>名前順</Text>
        </TouchableOpacity>
        <TouchableOpacity
          onPress={() => setSortBy('likes')}}
        >
          <Text>いいね順</Text>
        </TouchableOpacity>
      </View>
      <View>
        <Text>地域:</Text>
        <Picker
          selectedValue={region}
          onValueChange={(val) => setRegion(val)}
        >
          {REGIONS.map((r) => (
            <Picker.Item label={r} value={r} key={r} />
          ))}
        </Picker>
      </View>
      <View>
        <Text>年齢:</Text>
        <TextInput
          keyboardType="number-pad"
          value={minAge?.toString() || ''}
          onChangeText={(v) => setMinAge(Number(v))}
          placeholder="最小"
        />
        <TextInput
          keyboardType="number-pad"
          value={maxAge?.toString() || ''}
          onChangeText={(v) => setMaxAge(Number(v))}
          placeholder="最大"
        />
      </View>
      <View>
        <Text>パート:</Text>
        <Picker
          selectedValue={partFilter}
          onValueChange={(val) => setPartFilter(val)}
        >
          <Picker.Item label="すべて" value={null} />
          {PARTS.map((p) => (
            <Picker.Item label={p} value={p} key={p} />
          ))}
        </Picker>
      </View>
    </View>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\components\ui\BackFAB.js =====
import React from 'react';
import { useNavigation } from '@react-navigation/native';
import { TouchableOpacity, Text } from 'react-native';

export default function BackFAB({ onPress }) {
  const navigation = useNavigation();

  const handlePress = () => {
    if (onPress) {
      onPress();
    } else if (navigation.canGoBack()) {
      navigation.goBack();
    } else {
      console.warn('BackFAB: 戻る操作ができません');
    }
  };

  return (
    <TouchableOpacity onPress={handlePress}>
      <Text>← 戻る</Text>
    </TouchableOpacity>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\components\ui\Button.js =====
import React from 'react';
import { TouchableOpacity, Text } from 'react-native';

export default function Button({ title, onPress }) {
  return (
    <TouchableOpacity onPress={onPress}>
      <Text>{title}</Text>
    </TouchableOpacity>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\components\ui\CommentItem.js =====
import React from 'react';
import { View, Text, Image } from 'react-native';

export default function CommentItem({ avatar, nickname, content, createdAt }) {
  return (
    <View>
      <Image source={{ uri: avatar }} style={{ width: 30, height: 30, borderRadius: 15, marginRight: 8 }} />
      <View>
        <Text>{nickname}</Text>
        <Text>{content}</Text>
        <Text>
          {new Date(createdAt).toLocaleString('ja-JP')}
        </Text>
      </View>
    </View>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\components\ui\LikeButton.js =====
import React, { useEffect, useState } from 'react';
import { Text, TouchableOpacity, Alert } from 'react-native';
import { useAuthStore } from '../../store/useAuthStore';
import { supabase } from '../../api/supabaseClient';

export default function LikeButton({ to_user_id }) {
  const user = useAuthStore((state) => state.user);
  const [hasLiked, setHasLiked] = useState(false);
  const [count, setCount] = useState(0);

  useEffect(() => {
    checkLiked();
    fetchCount();
  }, []);

  const checkLiked = async () => {
    const { data } = await supabase
      .from('likes')
      .select()
      .eq('from_user_id', user.id)
      .eq('to_user_id', to_user_id);
    if (data.length > 0) setHasLiked(true);
  };

  const fetchCount = async () => {
    const { count } = await supabase
      .from('likes')
      .select('*', { count: 'exact', head: true })
      .eq('to_user_id', to_user_id);
    setCount(count || 0);
  };

  const handleLike = async () => {
    if (user.id === to_user_id) {
      Alert.alert('😅', '自分には「いいね」できません');
      return;
    }
    if (hasLiked) {
      Alert.alert('👍', '既に「いいね」しました');
      return;
    }

    const { error } = await supabase.from('likes').insert({
      from_user_id: user.id,
      to_user_id,
    });

    if (!error) {
      await supabase.from('notifications').insert({
        user_id: to_user_id,
        type: 'like',
        reference_id: user.id,
      });
      setHasLiked(true);
      setCount((prev) => prev + 1);
    }
  };

  return (
    <TouchableOpacity onPress={handleLike}>
      <Text>❤️ いいね数: {count}</Text>
    </TouchableOpacity>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\components\ui\ProfileImage.js =====
import React from 'react';
import { Image, View, Text, TouchableOpacity } from 'react-native';

export default function ProfileImage({ uri, size = 80, onPress }) {
  const content = uri ? (
    <Image
      source={{ uri }}
      style={{
        width: size,
        height: size,
        borderRadius: size / 2,
      }}
    />
  ) : (
    <View
      style={{
        width: size,
        height: size,
        borderRadius: size / 2,
        backgroundColor: '#eee',
        alignItems: 'center',
        justifyContent: 'center',
      }}
    >
      <Text style={{ color: '#bbb' }}>画像</Text>
    </View>
  );

  if (onPress) {
    return (
      <TouchableOpacity onPress={onPress} activeOpacity={0.7}>
        {content}
      </TouchableOpacity>
    );
  }
  return content;
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\components\ui\ProfileItem.js =====
import React from 'react';
import { View, Text } from 'react-native';

export default function ProfileItem({ label, value, multiline = false }) {
  return (
    <View>
      <Text>{label}</Text>
      <View>
        <Text>{value}</Text>
      </View>
    </View>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\components\ui\ReadOnlyTagGroup.js =====
import React from 'react';
import { View, Text } from 'react-native';

export default function ReadOnlyTagGroup({ title, items = [] }) {
  return (
    <View>
      <Text>{title}</Text>
      <View style={{ flexDirection: 'row', flexWrap: 'wrap' }}>
        {items.map((item) => (
          <View key={item} style={{ margin: 4 }}>
            <Text>{item}</Text>
          </View>
        ))}
      </View>
    </View>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\components\ui\SectionTitle.js =====
import React from 'react';
import { Text } from 'react-native';

export default function SectionTitle({ title }) {
  return <Text>{title}</Text>;
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\constants\days.js =====
// src/constants/days.js

export const DAYS = ['月', '火', '水', '木', '金', '土', '日'];


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\constants\directions.js =====
// src/constants/directions.js
export const DIRECTIONS = [
  'オリジナル',
  'コピー',
  'プロ志向',
  'アマチュア',
  'ライブ中心',
  'レコーディング目的',
  'YouTube活動',
];


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\constants\genders.js =====
// src/constants/genders.js

export const GENDERS = ['男性', '女性', '不問'];


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\constants\genres.js =====
// src/constants/genres.js
export const GENRES = [
  'J-POP',
  'ロック',
  'ポップス',
  'ジャズ',
  'メタル',
  'ヒップホップ',
  'アニメソング',
  'ボカロ',
  'R&B',
  'EDM',
  'クラシック',
  'アイドル',
  'パンク',
  'ブルース',
  'ファンク',
  'レゲエ',
  'サーフミュージック',
  'シティポップ',
  '昭和歌謡',
  'オルタナティブ',
];


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\constants\parts.js =====
// src/constants/parts.js
export const PARTS = [
  'ボーカル',
  'ギター',
  'ベース',
  'ドラム',
  'キーボード',
  'DTM',
  '作詞',
  '作曲',
  '編曲',
  'ミキシング',
  'プロデュース',
  'その他',
];


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\constants\prefectures.js =====
// src/constants/prefectures.js
export const PREFECTURES = [
  '北海道',
  '青森県',
  '岩手県',
  '宮城県',
  '秋田県',
  '山形県',
  '福島県',
  '茨城県',
  '栃木県',
  '群馬県',
  '埼玉県',
  '千葉県',
  '東京都',
  '神奈川県',
  '新潟県',
  '富山県',
  '石川県',
  '福井県',
  '山梨県',
  '長野県',
  '岐阜県',
  '静岡県',
  '愛知県',
  '三重県',
  '滋賀県',
  '京都府',
  '大阪府',
  '兵庫県',
  '奈良県',
  '和歌山県',
  '鳥取県',
  '島根県',
  '岡山県',
  '広島県',
  '山口県',
  '徳島県',
  '香川県',
  '愛媛県',
  '高知県',
  '福岡県',
  '佐賀県',
  '長崎県',
  '熊本県',
  '大分県',
  '宮崎県',
  '鹿児島県',
  '沖縄県',
];


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\hooks\useUnreadNotifications.js =====
//src/hooks/useUnredNotifications.js

import { useEffect, useState } from 'react';
import { supabase } from '../api/supabaseClient';
import { useAuthStore } from '../store/useAuthStore';

export function useUnreadNotifications() {
  const [count, setCount] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const user = useAuthStore((state) => state.user);

  useEffect(() => {
    if (user?.id) {
      fetchUnreadCount();
    }
  }, [user]);

  const fetchUnreadCount = async () => {
    setIsLoading(true);
    const { count, error } = await supabase
      .from('notifications')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .eq('read', false);
    if (!error) setCount(count);
    setIsLoading(false);
  };

  return { count, isLoading };
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\modals\BandPostModal.js =====
import React, { useState, useEffect } from 'react';
import {
  Modal,
  View,
  Text,
  TextInput,
  TouchableOpacity,
  Alert,
  ScrollView,
  Switch,
  KeyboardAvoidingView,
  Platform,
  TouchableWithoutFeedback,
  Keyboard,
} from 'react-native';
import { supabase } from '../api/supabaseClient';
import { useAuthStore } from '../store/useAuthStore';
import { PARTS } from '../constants/parts';
import { GENRES } from '../constants/genres';
import { PREFECTURES } from '../constants/prefectures';
import { DAYS } from '../constants/days';
import { DIRECTIONS } from '../constants/directions';
import { GENDERS } from '../constants/genders';

import CheckBoxGroup from '../components/forms/CheckBoxGroup';
import DropdownSelector from '../components/forms/DropdownSelector';

export default function BandPostModal({
  visible,
  onClose,
  onPostCreated,
  mode = 'create',
  initialData = {},
}) {
  const user = useAuthStore((state) => state.user);
  const isEdit = mode === 'edit';

  const [title, setTitle] = useState('');
  const [region, setRegion] = useState('');
  const [description, setDescription] = useState('');
  const [selectedParts, setSelectedParts] = useState([]);
  const [selectedGenres, setSelectedGenres] = useState([]);
  const [isPublic, setIsPublic] = useState(true);
  const [postToX, setPostToX] = useState(false);
  const [activityDays, setActivityDays] = useState([]);
  const [directions, setDirections] = useState([]);
  const [gender, setGender] = useState('');
  const [ageMin, setAgeMin] = useState('');
  const [ageMax, setAgeMax] = useState('');
  const [isBeginnerOk, setIsBeginnerOk] = useState(false);
  const [demoUrl, setDemoUrl] = useState('');

  useEffect(() => {
    if (isEdit && initialData) {
      setTitle(initialData.title || '');
      setRegion(initialData.region || '');
      setDescription(initialData.description || '');
      setSelectedParts(initialData.parts || []);
      setSelectedGenres(initialData.genres || []);
      setIsPublic(initialData.is_public ?? true);
      setPostToX(initialData.post_to_x ?? false);
      setActivityDays(initialData.activity_days || []);
      setDirections(initialData.directions || []);
      setGender(initialData.gender || '');
      setAgeMin(initialData.age_range?.split('~')[0] || '');
      setAgeMax(initialData.age_range?.split('~')[1] || '');
      setIsBeginnerOk(initialData.is_beginner_ok ?? false);
      setDemoUrl(initialData.demo_url || '');
    } else {
      setTitle('');
      setRegion('');
      setDescription('');
      setSelectedParts([]);
      setSelectedGenres([]);
      setIsPublic(true);
      setPostToX(false);
      setActivityDays([]);
      setDirections([]);
      setGender('');
      setAgeMin('');
      setAgeMax('');
      setIsBeginnerOk(false);
      setDemoUrl('');
    }
  }, [visible]);

  const handleSubmit = async () => {
    if (
      !title ||
      !region ||
      !description ||
      selectedParts.length === 0 ||
      selectedGenres.length === 0
    ) {
      Alert.alert('すべての項目を入力してください');
      return;
    }

    const payload = {
      user_id: user.id,
      title,
      region,
      description,
      parts: selectedParts,
      genres: selectedGenres,
      is_public: isPublic,
      post_to_x: postToX,
      activity_days: activityDays,
      directions,
      gender,
      age_range: ageMin && ageMax ? `${ageMin}~${ageMax}` : '',
      is_beginner_ok: isBeginnerOk,
      demo_url: demoUrl,
    };

    if (isEdit) {
      const { error } = await supabase
        .from('band_posts')
        .update(payload)
        .eq('id', initialData.id);
      if (error) return Alert.alert('更新に失敗しました', error.message);
    } else {
      const { error } = await supabase.from('band_posts').insert(payload);
      if (error) return Alert.alert('投稿に失敗しました', error.message);
    }

    onClose();
    onPostCreated();
  };

  return (
    <Modal visible={visible} animationType="slide" transparent>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      >
        <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
          <View>
            <ScrollView>
              <Text>
                {isEdit ? '📝 投稿を編集' : '✍️ 新規投稿'}
              </Text>

              <TextInput
                placeholder="タイトル"
                value={title}
                onChangeText={setTitle}
              />

              <DropdownSelector
                label="地域"
                options={PREFECTURES}
                selected={region}
                onSelect={setRegion}
              />

              <CheckBoxGroup
                label="担当パート"
                options={PARTS}
                selected={selectedParts}
                onChange={setSelectedParts}
              />

              <CheckBoxGroup
                label="ジャンル"
                options={GENRES}
                selected={selectedGenres}
                onChange={setSelectedGenres}
              />

              <TextInput
                placeholder="内容を入力してください"
                value={description}
                onChangeText={setDescription}
                multiline
              />

              <CheckBoxGroup
                label="活動曜日"
                options={DAYS}
                selected={activityDays}
                onChange={setActivityDays}
              />

              <CheckBoxGroup
                label="活動スタイル"
                options={DIRECTIONS}
                selected={directions}
                onChange={setDirections}
              />

              <CheckBoxGroup
                label="募集性別"
                options={['男性', '女性', '不問']}
                selected={gender ? [gender] : []}
                onChange={(arr) => setGender(arr[0])}
              />

              <Text>募集年齢</Text>
              <View>
                <TextInput
                  placeholder="最低年齢"
                  keyboardType="numeric"
                  value={ageMin}
                  onChangeText={setAgeMin}
                />
                <Text>〜</Text>
                <TextInput
                  placeholder="最高年齢"
                  keyboardType="numeric"
                  value={ageMax}
                  onChangeText={setAgeMax}
                />
              </View>

              <Text>参考URL</Text>
              <TextInput
                placeholder="X・Instagram・DemoURLなど"
                value={demoUrl}
                onChangeText={setDemoUrl}
              />

              <View>
                <Text>初心者OK</Text>
                <Switch value={isBeginnerOk} onValueChange={setIsBeginnerOk} />
              </View>

              <View>
                <Text>公開する</Text>
                <Switch value={isPublic} onValueChange={setIsPublic} />
              </View>

              <View>
                <Text>Xにも投稿</Text>
                <Switch value={postToX} onValueChange={setPostToX} />
              </View>

              <View>
                <TouchableOpacity onPress={onClose}>
                  <Text>閉じる</Text>
                </TouchableOpacity>
                <TouchableOpacity onPress={handleSubmit}>
                  <Text>{isEdit ? '更新' : '投稿'}</Text>
                </TouchableOpacity>
              </View>
            </ScrollView>
          </View>
        </TouchableWithoutFeedback>
      </KeyboardAvoidingView>
    </Modal>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\modals\GroupChatRoomModal.js =====
import React, { useState, useEffect } from 'react';
import {
  Modal, View, Text, TextInput,
  TouchableOpacity, Alert, Switch, KeyboardAvoidingView,
  Platform, TouchableWithoutFeedback, Keyboard, ScrollView,
} from 'react-native';
import { supabase } from '../api/supabaseClient';
import { useAuthStore } from '../store/useAuthStore';

export default function GroupChatRoomModal({
  visible,
  onClose,
  onCreated,
  initialData = {},
  mode = 'create',
}) {
  const user = useAuthStore((state) => state.user);
  const isEdit = mode === 'edit';

  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [password, setPassword] = useState('');
  const [isPublic, setIsPublic] = useState(true);
  const [maxMembers, setMaxMembers] = useState('50');
  const [notice, setNotice] = useState('');

  useEffect(() => {
    if (isEdit && initialData) {
      setName(initialData.name || '');
      setDescription(initialData.description || '');
      setPassword(initialData.password || '');
      setIsPublic(initialData.is_public ?? true);
      setMaxMembers(initialData.max_members?.toString() || '50');
      setNotice(initialData.notice || '');
    } else {
      setName('');
      setDescription('');
      setPassword('');
      setIsPublic(true);
      setMaxMembers('50');
      setNotice('');
    }
  }, [visible]);

  const handleSubmit = async () => {
    if (!name || !maxMembers) {
      Alert.alert('必須項目を入力してください');
      return;
    }
    const payload = {
      name,
      description,
      owner_id: user.id,
      password: password || null,
      is_public: isPublic,
      max_members: Number(maxMembers),
      notice,
    };
    let error;
    if (isEdit) {
      ({ error } = await supabase.from('group_chat_rooms').update(payload).eq('id', initialData.id));
    } else {
      ({ error } = await supabase.from('group_chat_rooms').insert(payload));
    }
    if (error) return Alert.alert('ルームの作成・編集に失敗しました', error.message);

    onClose();
    onCreated?.();
  };

  return (
    <Modal visible={visible} animationType="slide" transparent>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      >
        <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
          <View>
            <ScrollView>
              <Text>
                {isEdit ? 'ルーム編集' : 'グループチャットルーム作成'}
              </Text>
              <TextInput
                placeholder="ルーム名"
                value={name}
                onChangeText={setName}
                maxLength={24}
              />
              <TextInput
                placeholder="説明 (任意)"
                value={description}
                onChangeText={setDescription}
                multiline
              />
              <TextInput
                placeholder="パスワード (任意)"
                value={password}
                onChangeText={setPassword}
                secureTextEntry
              />
              <TextInput
                placeholder="最大人数 (10~100)"
                value={maxMembers}
                onChangeText={setMaxMembers}
                keyboardType="numeric"
                maxLength={3}
              />
              <TextInput
                placeholder="ルームの案内・お知らせ (任意)"
                value={notice}
                onChangeText={setNotice}
                multiline
              />

              <View>
                <Text>公開ルーム</Text>
                <Switch value={isPublic} onValueChange={setIsPublic} />
              </View>
              <View>
                <TouchableOpacity onPress={onClose}>
                  <Text>閉じる</Text>
                </TouchableOpacity>
                <TouchableOpacity onPress={handleSubmit}>
                  <Text>{isEdit ? '編集' : '作成'}</Text>
                </TouchableOpacity>
              </View>
            </ScrollView>
          </View>
        </TouchableWithoutFeedback>
      </KeyboardAvoidingView>
    </Modal>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\modals\NotificationsModal.js =====
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  FlatList,
  TouchableOpacity,
  ActivityIndicator,
  KeyboardAvoidingView,
  TouchableWithoutFeedback,
  Keyboard,
  Modal,
  Platform,
} from 'react-native';
import { supabase } from '../api/supabaseClient';
import { useAuthStore } from '../store/useAuthStore';
import { useNavigation } from '@react-navigation/native';
import BackFAB from '../components/ui/BackFAB';
import { getNotificationMessage } from '../utils/notifications';

export default function NotificationsModal({
  visible,
  onClose,
  onProfileSelect,
}) {
  const user = useAuthStore((state) => state.user);
  const navigation = useNavigation();
  const [notifications, setNotifications] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (visible) {
      fetchNotifications();
    } else {
      setNotifications([]);
    }
  }, [visible]);

  const fetchNotifications = async () => {
    setLoading(true);
    try {
      const { data, error } = await supabase
        .from('notifications')
        .select(`*, from:users(id, nickname, avatar_url)`)
        .eq('user_id', user.id)
        .order('created_at', { ascending: false });

      if (!error) setNotifications(data || []);
    } finally {
      setLoading(false);
    }
  };

  const markAsRead = async (id) => {
    await supabase.from('notifications').update({ read: true }).eq('id', id);
    fetchNotifications();
  };

  const renderItem = ({ item }) => {
    const { type, read, from } = item;

    return (
      <TouchableOpacity
        onPress={() => {
          markAsRead(item.id);
          onProfileSelect?.(from);
        }}
      >
        <Text>
          {getNotificationMessage(type, from?.nickname)}
        </Text>
        <Text>
          {new Date(item.created_at).toLocaleString('ja-JP')}
        </Text>
      </TouchableOpacity>
    );
  };

  return (
    <Modal visible={visible} animationType="slide" transparent>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      >
        <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
          <View>
            <View>
              {loading ? (
                <ActivityIndicator size="large" />
              ) : (
                <FlatList
                  data={notifications}
                  keyExtractor={(item) => item.id.toString()}
                  renderItem={renderItem}
                  ListEmptyComponent={<Text>通知はまだありません</Text>}
                />
              )}
            </View>
            <BackFAB onPress={onClose} />
          </View>
        </TouchableWithoutFeedback>
      </KeyboardAvoidingView>
    </Modal>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\modals\OnboardingModal.js =====
import React, { useState, useEffect } from 'react';
import {
  Modal,
  View,
  Text,
  TextInput,
  TouchableWithoutFeedback,
  Keyboard,
  Alert,
  TouchableOpacity,
  ScrollView,
  Image,
  Platform,
  ActivityIndicator,
  KeyboardAvoidingView,
} from 'react-native';
import DateTimePickerModal from 'react-native-modal-datetime-picker';
import { supabase } from '../api/supabaseClient';
import { useAuthStore } from '../store/useAuthStore';
import * as ImagePicker from 'expo-image-picker';
import Constants from 'expo-constants';
import CheckBoxGroup from '../components/forms/CheckBoxGroup';
import { PARTS } from '../constants/parts';
import { GENRES } from '../constants/genres';
import { PREFECTURES } from '../constants/prefectures';
import { format } from 'date-fns';
import { ja } from 'date-fns/locale';

export default function OnboardingModal({
  visible,
  onClose,
  initialProfile = {},
  mode = 'onboarding',
}) {
  const user = useAuthStore((state) => state.user);
  const [nickname, setNickname] = useState('');
  const [gender, setGender] = useState('');
  const [birthday, setBirthday] = useState('');
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [region, setRegion] = useState(PREFECTURES[0]);
  const [parts, setParts] = useState([]);
  const [genres, setGenres] = useState([]);
  const [song, setSong] = useState('');
  const [meaning, setMeaning] = useState('');
  const [intro, setIntro] = useState('');
  const [selfIntro, setSelfIntro] = useState('');
  const [avatarUrl, setAvatarUrl] = useState('');
  const [avatar, setAvatar] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (visible) {
      setLoading(true);
      setTimeout(() => {
        if (initialProfile && Object.keys(initialProfile).length > 0) {
          applyInitialValues();
        }
        setLoading(false);
      }, 100);
    }
  }, [visible, initialProfile]);

  const applyInitialValues = () => {
    if (!initialProfile || Object.keys(initialProfile).length === 0) return;
    setNickname(initialProfile.nickname ?? '');
    setGender(initialProfile.gender ?? '');
    setBirthday(initialProfile.birthday ?? '');
    setRegion(initialProfile.region ?? PREFECTURES[0]);
    setParts(initialProfile.parts?.split(',') ?? []);
    setGenres(initialProfile.genres?.split(',') ?? []);
    setSong(initialProfile.song ?? '');
    setMeaning(initialProfile.meaning ?? '');
    setIntro(initialProfile.intro ?? '');
    setSelfIntro(initialProfile.self_intro ?? '');
    setAvatarUrl(initialProfile.avatar_url ?? '');
  };

  const pickImage = async () => {
    const permissionResult =
      await ImagePicker.requestMediaLibraryPermissionsAsync();
    if (!permissionResult.granted) {
      Alert.alert('アクセス拒否', '画像アクセスを許可してください。');
      return;
    }
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      quality: 0.7,
    });
    if (!result.canceled) {
      setAvatar(result.assets[0].uri);
    }
  };

  const handleDateConfirm = (date) => {
    setBirthday(format(date, 'yyyy-MM-dd', { locale: ja }));
    setShowDatePicker(false);
  };

  const handleSave = async () => {
    if (
      !nickname ||
      !gender ||
      !birthday ||
      !region ||
      parts.length === 0 ||
      !song ||
      !meaning ||
      !intro ||
      !selfIntro
    ) {
      Alert.alert('全ての項目を入力してください。');
      return;
    }
    if (
      song.length > 50 ||
      meaning.length > 50 ||
      intro.length > 50 ||
      selfIntro.length > 300
    ) {
      Alert.alert('入力制限を超えました。');
      return;
    }

    let avatar_url = avatarUrl;
    if (avatar) {
      const ext = avatar.split('.').pop();
      const fileName = `${user.id}_${Date.now()}.${ext}`;
      const { error: uploadError } = await supabase.storage
        .from('avatars')
        .upload(`public/${fileName}`, {
          uri: avatar,
          type: 'image/jpeg',
          name: fileName,
        });
      if (uploadError) {
        Alert.alert('画像アップロード失敗', uploadError.message);
        return;
      }
      const { SUPABASE_URL } = Constants.expoConfig.extra;
      avatar_url = `${SUPABASE_URL}/storage/v1/object/public/avatars/public/${fileName}`;
    }

    const { data, error } = await supabase
      .from('users')
      .update({
        nickname,
        gender,
        birthday,
        region,
        parts: parts.join(','),
        genres: genres.join(','),
        song,
        meaning,
        intro,
        self_intro: selfIntro,
        avatar_url,
      })
      .eq('id', user.id)
      .select();

    if (error) {
      Alert.alert('保存に失敗しました。', error.message);
    } else if (!data || data.length === 0) {
      Alert.alert('更新できませんでした。ユーザー情報が見つかりません。');
    } else {
      Alert.alert(
        mode === 'edit' ? '変更完了' : 'ようこそ！',
        'プロフィールが保存されました。',
      );
      onClose();
    }
  };

  if (loading) {
    return (
      <Modal visible={visible} transparent animationType="slide">
        <View>
          <ActivityIndicator size="large" />
        </View>
      </Modal>
    );
  }

  return (
    <Modal visible={visible} transparent animationType="slide">
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      >
        <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
          <View>
            <ScrollView>
              <Text>
                {mode === 'edit' ? '🛠 プロフィール編集' : '👋 初めまして！'}
              </Text>
              {avatar ? (
                <Image source={{ uri: avatar }} />
              ) : avatarUrl ? (
                <Image source={{ uri: avatarUrl }} />
              ) : (
                <TouchableOpacity onPress={pickImage}>
                  <Text>画像</Text>
                </TouchableOpacity>
              )}

              <Text>ニックネーム</Text>
              <TextInput
                value={nickname}
                onChangeText={setNickname}
                placeholder="例: たろう"
              />

              <Text>性別</Text>
              <View>
                {['男性', '女性', '指定なし'].map((item) => (
                  <TouchableOpacity
                    key={item}
                    onPress={() => setGender(item)}
                  >
                    <Text>{item}</Text>
                  </TouchableOpacity>
                ))}
              </View>

              <Text>生年月日</Text>
              <TouchableOpacity
                onPress={() => setShowDatePicker(true)}
              >
                <Text>{birthday || '選択してください'}</Text>
              </TouchableOpacity>
              <DateTimePickerModal
                isVisible={showDatePicker}
                mode="date"
                onConfirm={handleDateConfirm}
                onCancel={() => setShowDatePicker(false)}
              />

              <Text>地域</Text>
              <ScrollView>
                {PREFECTURES.map((item) => (
                  <TouchableOpacity
                    key={item}
                    onPress={() => setRegion(item)}
                  >
                    <Text>{item}</Text>
                  </TouchableOpacity>
                ))}
              </ScrollView>

              <Text>パート</Text>
              <CheckBoxGroup
                options={PARTS}
                selected={parts}
                onChange={setParts}
              />

              <Text>ジャンル</Text>
              <CheckBoxGroup
                options={GENRES}
                selected={genres}
                onChange={setGenres}
              />

              <Text>好きな曲</Text>
              <TextInput
                value={song}
                onChangeText={setSong}
                placeholder="50文字以内"
              />

              <Text>その曲の好きな理由</Text>
              <TextInput
                value={meaning}
                onChangeText={setMeaning}
                placeholder="50文字以内"
              />

              <Text>音楽を始めたきっかけ</Text>
              <TextInput
                value={intro}
                onChangeText={setIntro}
                placeholder="50文字以内"
              />

              <Text>自己紹介</Text>
              <TextInput
                value={selfIntro}
                onChangeText={setSelfIntro}
                placeholder="300文字以内"
                multiline
              />

              <TouchableOpacity onPress={handleSave}>
                <Text>保存</Text>
              </TouchableOpacity>
            </ScrollView>
          </View>
        </TouchableWithoutFeedback>
      </KeyboardAvoidingView>
    </Modal>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\modals\ProfileEditModal.js =====
import React, { useEffect, useState } from 'react';
import { Alert, Modal, View, ActivityIndicator } from 'react-native';
import OnboardingModal from './OnboardingModal';
import { useAuthStore } from '../store/useAuthStore';
import { supabase } from '../api/supabaseClient';

export default function ProfileEditModal({ visible, onClose }) {
  const user = useAuthStore((state) => state.user);
  const [profile, setProfile] = useState(null);

  useEffect(() => {
    if (!visible) return;

    const fetchProfile = async () => {
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .eq('id', user.id)
        .single();

      if (error) {
        Alert.alert('エラー', 'プロフィールの取得に失敗しました');
      } else {
        setProfile(data);
      }
    };

    fetchProfile();
  }, [visible]);

  const handleClose = () => {
    onClose?.();
    Alert.alert('完了', 'プロフィール編集を終了しました。');
  };

  if (!profile) {
    return (
      <Modal visible={visible} transparent animationType="slide">
        <View>
          <ActivityIndicator size="large" />
        </View>
      </Modal>
    );
  }

  return (
    <Modal visible={visible} animationType="slide" transparent>
      {profile ? (
        <View>
          <OnboardingModal
            visible={true}
            onClose={handleClose}
            initialProfile={profile}
            mode="edit"
          />
        </View>
      ) : (
        <View>
          <ActivityIndicator size="large" />
        </View>
      )}
    </Modal>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\modals\ProfileViewModal.js =====
import React, { useEffect, useState } from 'react';
import {
  Modal,
  View,
  Text,
  Image,
  ScrollView,
  TextInput,
  TouchableOpacity,
  Alert,
  ActivityIndicator,
} from 'react-native';
import { supabase } from '../api/supabaseClient';
import { useAuthStore } from '../store/useAuthStore';
import CommentList from '../components/forms/CommentList';
import BackFAB from '../components/ui/BackFAB';

export default function ProfileViewModal({ visible, profile, onClose }) {
  const currentUser = useAuthStore((state) => state.user);

  const isSelf = currentUser?.id === profile?.id;

  const [comments, setComments] = useState([]);
  const [newComment, setNewComment] = useState('');
  const [likeCount, setLikeCount] = useState(0);
  const [hasLiked, setHasLiked] = useState(false);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!visible || !profile?.id) return;
    fetchData();
  }, [visible, profile]);

  const fetchData = async () => {
    setLoading(true);
    await Promise.all([fetchComments(), fetchLikeCount(), checkIfLiked()]);
    setLoading(false);
  };

  const fetchComments = async () => {
    const { data } = await supabase
      .from('comments')
      .select('*, from_user_id!inner(nickname, avatar_url)')
      .eq('to_user_id', profile.id)
      .order('created_at', { ascending: false });
    setComments(data || []);
  };

  const fetchLikeCount = async () => {
    const { count } = await supabase
      .from('likes')
      .select('*', { count: 'exact', head: true })
      .eq('to_user_id', profile.id);
    setLikeCount(count || 0);
  };

  const checkIfLiked = async () => {
    const { data } = await supabase
      .from('likes')
      .select('id')
      .eq('from_user_id', currentUser.id)
      .eq('to_user_id', profile.id);
    setHasLiked(data?.length > 0);
  };

  const handleLike = async () => {
    if (isSelf || hasLiked) return;

    const { data, error } = await supabase
      .from('likes')
      .insert({ from_user_id: currentUser.id, to_user_id: profile.id })
      .select()
      .single();

    if (!error && data) {
      setHasLiked(true);
      setLikeCount((prev) => prev + 1);
      await supabase.from('notifications').insert({
        user_id: profile.id,
        type: 'like',
        reference_id: data.id,
      });
    } else {
      Alert.alert('エラー', 'いいねに失敗しました');
    }
  };

  const handleCommentSubmit = async () => {
    if (!newComment.trim()) return;
    const { data, error } = await supabase
      .from('comments')
      .insert({
        from_user_id: currentUser.id,
        to_user_id: profile.id,
        content: newComment,
      })
      .select()
      .single();

    if (!error && data) {
      await supabase.from('notifications').insert({
        user_id: profile.id,
        type: 'comment',
        reference_id: data.id,
      });
      setNewComment('');
      fetchComments();
    } else {
      Alert.alert('エラー', 'コメント投稿に失敗しました');
    }
  };

  return (
    <Modal visible={visible} animationType="slide" transparent>
      <View>
        <ScrollView>
          <View>
            <Image source={{ uri: profile.avatar_url }} />
            <Text>{profile.nickname}</Text>
            <View />

            <View>
              <Text>性別</Text>
              <Text>{profile.gender || '未設定'}</Text>

              <Text>生年月日</Text>
              <Text>{profile.birthday || '未設定'}</Text>

              <Text>地域</Text>
              <Text>{profile.region || '未設定'}</Text>

              <Text>人生曲</Text>
              <Text>{profile.song || '未設定'}</Text>

              <Text>バンドとは</Text>
              <Text>{profile.meaning || '未設定'}</Text>

              <Text>一言紹介</Text>
              <Text>{profile.intro || '未設定'}</Text>

              <Text>自己紹介</Text>
              <Text>{profile.self_intro || '未設定'}</Text>
            </View>

            <View>
              <Text>❤️ いいね数: {likeCount}</Text>
              {!isSelf && !hasLiked && (
                <TouchableOpacity onPress={handleLike}>
                  <Text>👍 いいね</Text>
                </TouchableOpacity>
              )}
            </View>
          </View>

          <View>
            <Text>💬 コメント</Text>
            {loading ? (
              <ActivityIndicator />
            ) : comments.length === 0 ? (
              <Text>まだコメントがありません</Text>
            ) : (
              <CommentList
                comments={comments}
                currentUserId={currentUser.id}
                onDeleted={fetchComments}
              />
            )}

            {!isSelf && (
              <View>
                <TextInput
                  placeholder="コメントを入力..."
                  value={newComment}
                  onChangeText={setNewComment}
                />
                <TouchableOpacity onPress={handleCommentSubmit}>
                  <Text>投稿</Text>
                </TouchableOpacity>
              </View>
            )}
          </View>
        </ScrollView>
        <BackFAB onPress={onClose} />
      </View>
    </Modal>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\modals\SearchModal.js =====
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  Modal,
  ActivityIndicator,
  FlatList,
  KeyboardAvoidingView,
  TouchableWithoutFeedback,
  Keyboard,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { supabase } from '../api/supabaseClient';
import BackFAB from '../components/ui/BackFAB';

const CATEGORIES = ['ユーザー', 'バンド', 'セッション', 'コミュニティ'];

export default function SearchModal({
  visible,
  onClose,
  onSearch,
  onProfileSelect,
}) {
  const navigation = useNavigation();

  const [keyword, setKeyword] = useState('');
  const [category, setCategory] = useState('ユーザー');
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (!keyword.trim()) {
      setResults([]);
      return;
    }
    const timer = setTimeout(() => {
      fetchResults();
    }, 400);

    return () => clearTimeout(timer);
  }, [keyword, category]);

  const fetchResults = async () => {
    setLoading(true);
    let query;

    if (category === 'ユーザー') {
      query = supabase
        .from('users')
        .select('id, nickname, avatar_url, region')
        .ilike('nickname', `%${keyword}%`);
    } else {
      const table = category === 'バンド' ? 'band_posts' : 'session_posts';
      query = supabase
        .from(table)
        .select('id, title, region')
        .ilike('title', `%${keyword}%`);
    }

    const { data } = await query;
    setResults(data || []);
    setLoading(false);
  };

  const handleSubmit = () => {
    if (!keyword.trim()) return;
    if (onSearch) {
      onSearch({ keyword: keyword.trim(), category });
      onClose();
    }
  };

  const handleResultPress = (item) => {
    if (category === 'ユーザー' && onProfileSelect) {
      onProfileSelect(item);
    } else {
      onClose();
      navigation.navigate(
        category === 'バンド' ? 'BandDetail' : 'SessionDetail',
        { post: item },
      );
    }
  };

  const renderItem = ({ item }) => (
    <TouchableOpacity onPress={() => handleResultPress(item)}>
      <Text>
        {item.nickname || item.title}（{item.region || '地域未設定'}）
      </Text>
    </TouchableOpacity>
  );

  return (
    <Modal visible={visible} animationType="slide" transparent>
      <KeyboardAvoidingView
        behavior="padding"
      >
        <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
          <View>
            <View>
              <Text>カテゴリ</Text>
              <View>
                {CATEGORIES.map((c) => (
                  <TouchableOpacity
                    key={c}
                    onPress={() => setCategory(c)}
                  >
                    <Text>
                      {c}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
              <TextInput
                placeholder="キーワードを入力..."
                value={keyword}
                onChangeText={setKeyword}
                returnKeyType="search"
                onSubmitEditing={handleSubmit}
              />
            </View>

            {loading ? (
              <ActivityIndicator />
            ) : results.length === 0 ? (
              <Text>
                該当する{category}はありません
              </Text>
            ) : (
              <>
                <Text>
                  🔍 検索結果（最大20件表示）
                </Text>
                <FlatList
                  data={results.slice(0, 20)}
                  keyExtractor={(item) => item.id?.toString()}
                  renderItem={renderItem}
                />
                {results.length > 5 && (
                  <TouchableOpacity
                    onPress={() => {
                      onClose();
                      navigation.navigate('SearchResults', {
                        keyword,
                        category,
                      });
                    }}
                  >
                    <Text>さらに見る ▶</Text>
                  </TouchableOpacity>
                )}
              </>
            )}

            <BackFAB onPress={onClose} />
          </View>
        </TouchableWithoutFeedback>
      </KeyboardAvoidingView>
    </Modal>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\modals\SessionPostModal.js =====
import React, { useState, useEffect } from 'react';
import {
  Modal,
  View,
  Text,
  TextInput,
  TouchableOpacity,
  Alert,
  ScrollView,
  Switch,
  KeyboardAvoidingView,
  Platform,
  TouchableWithoutFeedback,
  Keyboard,
} from 'react-native';
import { supabase } from '../api/supabaseClient';
import { useAuthStore } from '../store/useAuthStore';
import { PARTS } from '../constants/parts';
import { GENRES } from '../constants/genres';
import { PREFECTURES } from '../constants/prefectures';
import { DAYS } from '../constants/days';
import { DIRECTIONS } from '../constants/directions';
import CheckBoxGroup from '../components/forms/CheckBoxGroup';
import DropdownSelector from '../components/forms/DropdownSelector';

export default function SessionPostModal({
  visible,
  onClose,
  onPostCreated,
  mode = 'create',
  initialData = {},
}) {
  const user = useAuthStore((state) => state.user);
  const isEdit = mode === 'edit';

  const [title, setTitle] = useState('');
  const [region, setRegion] = useState('');
  const [description, setDescription] = useState('');
  const [selectedParts, setSelectedParts] = useState([]);
  const [selectedGenres, setSelectedGenres] = useState([]);
  const [isPublic, setIsPublic] = useState(true);
  const [postToX, setPostToX] = useState(false);
  const [activityDays, setActivityDays] = useState([]);
  const [directions, setDirections] = useState([]);
  const [gender, setGender] = useState('');
  const [ageMin, setAgeMin] = useState('');
  const [ageMax, setAgeMax] = useState('');
  const [isBeginnerOk, setIsBeginnerOk] = useState(false);
  const [demoUrl, setDemoUrl] = useState('');

  useEffect(() => {
    if (isEdit && initialData) {
      setTitle(initialData.title || '');
      setRegion(initialData.region || '');
      setDescription(initialData.description || '');
      setSelectedParts(initialData.parts || []);
      setSelectedGenres(initialData.genres || []);
      setIsPublic(initialData.is_public ?? true);
      setPostToX(initialData.post_to_x ?? false);
      setActivityDays(initialData.activity_days || []);
      setDirections(initialData.directions || []);
      setGender(initialData.gender || '');
      setAgeMin(initialData.age_range?.split('~')[0] || '');
      setAgeMax(initialData.age_range?.split('~')[1] || '');
      setIsBeginnerOk(initialData.is_beginner_ok ?? false);
      setDemoUrl(initialData.demo_url || '');
    } else {
      setTitle('');
      setRegion('');
      setDescription('');
      setSelectedParts([]);
      setSelectedGenres([]);
      setIsPublic(true);
      setPostToX(false);
      setActivityDays([]);
      setDirections([]);
      setGender('');
      setAgeMin('');
      setAgeMax('');
      setIsBeginnerOk(false);
      setDemoUrl('');
    }
  }, [visible]);

  const handleSubmit = async () => {
    if (
      !title ||
      !region ||
      !description ||
      selectedParts.length === 0 ||
      selectedGenres.length === 0
    ) {
      Alert.alert('全ての項目を入力してください');
      return;
    }

    const payload = {
      user_id: user.id,
      title,
      region,
      description,
      parts: selectedParts,
      genres: selectedGenres,
      is_public: isPublic,
      post_to_x: postToX,
      activity_days: activityDays,
      directions,
      gender,
      age_range: ageMin && ageMax ? `${ageMin}~${ageMax}` : '',
      is_beginner_ok: isBeginnerOk,
      demo_url: demoUrl,
    };

    const method = isEdit ? 'update' : 'insert';
    const table = 'session_posts';
    const query = isEdit
      ? supabase.from(table).update(payload).eq('id', initialData.id)
      : supabase.from(table).insert(payload);

    const { error } = await query;
    if (error)
      return Alert.alert(isEdit ? '更新失敗' : '投稿失敗', error.message);

    onClose();
    onPostCreated();
  };

  return (
    <Modal visible={visible} animationType="slide" transparent>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      >
        <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
          <ScrollView>
            <View>
              <Text>
                {isEdit ? '📝 投稿を編集' : '✍️ セッション募集'}
              </Text>

              <TextInput
                placeholder="タイトル"
                value={title}
                onChangeText={setTitle}
              />

              <DropdownSelector
                label="地域"
                options={PREFECTURES}
                selected={region}
                onSelect={setRegion}
              />
              <CheckBoxGroup
                label="担当パート"
                options={PARTS}
                selected={selectedParts}
                onChange={setSelectedParts}
              />
              <CheckBoxGroup
                label="ジャンル"
                options={GENRES}
                selected={selectedGenres}
                onChange={setSelectedGenres}
              />

              <TextInput
                placeholder="内容"
                value={description}
                onChangeText={setDescription}
                multiline
              />

              <CheckBoxGroup
                label="活動曜日"
                options={DAYS}
                selected={activityDays}
                onChange={setActivityDays}
              />
              <CheckBoxGroup
                label="活動方向性"
                options={DIRECTIONS}
                selected={directions}
                onChange={setDirections}
              />
              <CheckBoxGroup
                label="募集性別"
                options={['男性', '女性', '不問']}
                selected={gender ? [gender] : []}
                onChange={(arr) => setGender(arr[0])}
              />

              <Text>募集年齢</Text>
              <View>
                <TextInput
                  placeholder="最低年齢"
                  keyboardType="numeric"
                  value={ageMin}
                  onChangeText={setAgeMin}
                />
                <Text>〜</Text>
                <TextInput
                  placeholder="最高年齢"
                  keyboardType="numeric"
                  value={ageMax}
                  onChangeText={setAgeMax}
                />
              </View>

              <Text>参考URL</Text>
              <TextInput
                placeholder="X ・ Instagram ・ DemoURL など"
                value={demoUrl}
                onChangeText={setDemoUrl}
              />

              <View>
                <Text>初心者OK</Text>
                <Switch
                  value={isBeginnerOk}
                  onValueChange={setIsBeginnerOk}
                />
              </View>
              <View>
                <Text>公開する</Text>
                <Switch value={isPublic} onValueChange={setIsPublic} />
              </View>
              <View>
                <Text>Xにも投稿</Text>
                <Switch value={postToX} onValueChange={setPostToX} />
              </View>

              <View>
                <TouchableOpacity onPress={onClose}>
                  <Text>閉じる</Text>
                </TouchableOpacity>
                <TouchableOpacity
                  onPress={handleSubmit}
                >
                  <Text>{isEdit ? '更新' : '投稿'}</Text>
                </TouchableOpacity>
              </View>
            </View>
          </ScrollView>
        </TouchableWithoutFeedback>
      </KeyboardAvoidingView>
    </Modal>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\modals\UserMiniModal.js =====
import React from 'react';
import { Modal, View, Text, TouchableOpacity } from 'react-native';
import ProfileImage from '../components/ui/ProfileImage';

export default function UserMiniModal({ visible, user, onClose, onViewProfile, onChat }) {
  if (!user) return null;
  return (
    <Modal visible={visible} transparent animationType="fade">
      <View>
        <View>
          <ProfileImage uri={user.avatar_url} size={64} />
          <Text>{user.nickname}</Text>
          {user.region && <Text>地域: {user.region}</Text>}
          {user.parts && <Text>パート: {user.parts}</Text>}
          <View>
            <TouchableOpacity onPress={onViewProfile}>
              <Text>プロフィールを見る</Text>
            </TouchableOpacity>
            <TouchableOpacity onPress={onChat}>
              <Text>チャットする</Text>
            </TouchableOpacity>
          </View>
          <TouchableOpacity onPress={onClose}>
            <Text>閉じる</Text>
          </TouchableOpacity>
        </View>
      </View>
    </Modal>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\navigation\AuthStack.js =====
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { navigationRef } from './navigationRef';

import SignInScreen from '../screens/SignInScreen';
import SignUpScreen from '../screens/SignUpScreen';
import BandDetailScreen from '../screens/BandDetailScreen';
import SessionDetailScreen from '../screens/SessionDetailScreen';
import SearchResultsScreen from '../screens/SearchResultsScreen';
import PrivateChatRoomScreen from '../screens/PrivateChatRoomScreen';
import GroupChatRoomScreen from '../screens/GroupChatRoomScreen';
import MainWrapper from './MainWrapper';

const Stack = createNativeStackNavigator();

export default function AuthStack() {
  return (
    <NavigationContainer ref={navigationRef}>
      <Stack.Navigator screenOptions={{ headerShown: false }}>
        <Stack.Screen name="SignIn" component={SignInScreen} />
        <Stack.Screen name="SignUp" component={SignUpScreen} />
        <Stack.Screen name="Main" component={MainWrapper} />
        <Stack.Screen name="SearchResults" component={SearchResultsScreen} />
        <Stack.Screen name="BandDetail" component={BandDetailScreen} />
        <Stack.Screen name="SessionDetail" component={SessionDetailScreen} />
        <Stack.Screen name="PrivateChatRoom" component={PrivateChatRoomScreen} />
        <Stack.Screen name="GroupChatRoom" component={GroupChatRoomScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\navigation\BandStackNavigator.js =====
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import BandListScreen from '../screens/BandListScreen';
import BandDetailScreen from '../screens/BandDetailScreen';

const Stack = createNativeStackNavigator();

export default function BandStackNavigator() {
  return (
    <Stack.Navigator>
      <Stack.Screen
        name="BandList"
        component={BandListScreen}
        options={{ headerShown: false }}
      />
      <Stack.Screen
        name="BandDetail"
        component={BandDetailScreen}
        options={{ headerShown: false }}
      />
    </Stack.Navigator>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\navigation\DrawerNavigator.js =====
import React from 'react';
import { createDrawerNavigator } from '@react-navigation/drawer';
import { TouchableOpacity, View, Text } from 'react-native';
import Icon from 'react-native-vector-icons/Ionicons';
import { useNavigation } from '@react-navigation/native';
import { useUnreadNotifications } from '../hooks/useUnreadNotifications';

import ChatScreen from '../screens/ChatScreen';
import CommunityScreen from '../screens/CommunityScreen';
import StudioScreen from '../screens/StudioScreen';
import SettingsScreen from '../screens/SettingsScreen';
import BandStackNavigator from './BandStackNavigator';
import SessionStackNavigator from './SessionStackNavigator';

const Drawer = createDrawerNavigator();

function NotificationBell({ onPress }) {
  const unreadCount = useUnreadNotifications();

  return (
    <TouchableOpacity onPress={onPress}>
      <View>
        <Icon name="notifications-outline" size={24} color="#000" />
        {unreadCount > 0 && (
          <View>
            <Text>{unreadCount}</Text>
          </View>
        )}
      </View>
    </TouchableOpacity>
  );
}

// 일본어 네이티브 스타일로 타이틀 및 버튼명 현지화
function screenOptions(title, onOpenNotifications, onOpenSearch) {
  return ({ navigation }) => ({
    headerTitle: title,
    headerLeft: () => (
      <TouchableOpacity onPress={() => navigation.openDrawer()}>
        <Icon name="menu" size={24} color="#000" />
      </TouchableOpacity>
    ),
    headerRight: () => (
      <View style={{ flexDirection: 'row', alignItems: 'center' }}>
        <TouchableOpacity onPress={onOpenSearch}>
          <Icon
            name="search-outline"
            size={24}
            color="#000"
          />
        </TouchableOpacity>
        <NotificationBell onPress={onOpenNotifications} />
      </View>
    ),
  });
}

export default function DrawerNavigator({ onOpenNotifications, onOpenSearch }) {
  return (
    <Drawer.Navigator initialRouteName="Band">
      <Drawer.Screen
        name="Band"
        component={BandStackNavigator}
        options={screenOptions('バンド募集', onOpenNotifications, onOpenSearch)}
      />
      <Drawer.Screen
        name="Session"
        component={SessionStackNavigator}
        options={screenOptions(
          'メンバー募集',
          onOpenNotifications,
          onOpenSearch,
        )}
      />
      <Drawer.Screen
        name="Chat"
        component={ChatScreen}
        options={screenOptions('チャット', onOpenNotifications, onOpenSearch)}
      />
      <Drawer.Screen
        name="Community"
        component={CommunityScreen}
        options={screenOptions(
          'コミュニティ',
          onOpenNotifications,
          onOpenSearch,
        )}
      />
      <Drawer.Screen
        name="Studio"
        component={StudioScreen}
        options={screenOptions(
          'スタジオ探し',
          onOpenNotifications,
          onOpenSearch,
        )}
      />
      <Drawer.Screen
        name="Settings"
        component={SettingsScreen}
        options={screenOptions('設定', onOpenNotifications, onOpenSearch)}
      />
    </Drawer.Navigator>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\navigation\MainWrapper.js =====
import React, { useEffect, useState } from 'react';
import { View, ActivityIndicator } from 'react-native';
import { supabase } from '../api/supabaseClient';
import { useAuthStore } from '../store/useAuthStore';
import { navigationRef } from './navigationRef';

import DrawerNavigator from './DrawerNavigator';
import OnboardingModal from '../modals/OnboardingModal';
import ProfileViewModal from '../modals/ProfileViewModal';
import ProfileEditModal from '../modals/ProfileEditModal';
import NotificationsModal from '../modals/NotificationsModal';
import SearchModal from '../modals/SearchModal';

export default function MainWrapper() {
  const user = useAuthStore((state) => state.user);
  const [loading, setLoading] = useState(true);
  const [showOnboarding, setShowOnboarding] = useState(false);
  const [showProfileViewModal, setShowProfileViewModal] = useState(false);
  const [showProfileEditModal, setShowProfileEditModal] = useState(false);
  const [showNotificationsModal, setShowNotificationsModal] = useState(false);
  const [showSearchModal, setShowSearchModal] = useState(false);
  const [profileData, setProfileData] = useState(null);

  useEffect(() => {
    const checkProfile = async () => {
      if (!user?.id) return;
      const { data } = await supabase
        .from('users')
        .select('song, meaning, self_intro')
        .eq('id', user.id)
        .single();
      if (!data?.song || !data?.meaning || !data?.self_intro) {
        setShowOnboarding(true);
      }
      setLoading(false);
    };
    checkProfile();
  }, [user]);

  useEffect(() => {
    global.openNotificationsModal = () => setShowNotificationsModal(true);
    global.openSearchModal = () => setShowSearchModal(true);
    global.openProfileViewModal = (profile) => {
      setProfileData(profile);
      setShowProfileViewModal(true);
    };
    global.openProfileEditModal = () => setShowProfileEditModal(true);
  }, []);

  if (loading) {
    return <ActivityIndicator />;
  }

  return (
    <>
      <DrawerNavigator
        onOpenNotifications={() => setShowNotificationsModal(true)}
        onOpenSearch={() => setShowSearchModal(true)}
      />
      <OnboardingModal
        visible={showOnboarding}
        onClose={() => setShowOnboarding(false)}
        initialProfile={user}
      />

      {showProfileEditModal && (
        <ProfileEditModal onClose={() => setShowProfileEditModal(false)} />
      )}

      <NotificationsModal
        visible={showNotificationsModal}
        onClose={() => setShowNotificationsModal(false)}
        onProfileSelect={(profile) => {
          setProfileData(profile);
          setShowProfileViewModal(true);
        }}
      />
      {showProfileViewModal && profileData && (
        <ProfileViewModal
          visible={showProfileViewModal}
          profile={profileData}
          onClose={() => setShowProfileViewModal(false)}
        />
      )}

      {showSearchModal && (
        <SearchModal
          visible={true}
          onClose={() => setShowSearchModal(false)}
          onSearch={({ keyword, category }) => {
            setShowSearchModal(false);
            navigationRef.current?.navigate('SearchResults', {
              keyword,
              category,
            });
          }}
        />
      )}
    </>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\navigation\navigationRef.js =====
import { createNavigationContainerRef } from '@react-navigation/native';

export const navigationRef = createNavigationContainerRef();


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\navigation\SessionStackNavigator.js =====
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import SessionListScreen from '../screens/SessionListScreen';
import SessionDetailScreen from '../screens/SessionDetailScreen';

const Stack = createNativeStackNavigator();

export default function SessionStackNavigator() {
  return (
    <Stack.Navigator>
      <Stack.Screen
        name="SessionList"
        component={SessionListScreen}
        options={{ headerShown: false }}
      />
      <Stack.Screen
        name="SessionDetail"
        component={SessionDetailScreen}
        options={{ headerShown: false }}
      />
    </Stack.Navigator>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\screens\BandDetailScreen.js =====
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  Image,
  TouchableOpacity,
  ScrollView,
  Alert,
} from 'react-native';
import { format } from 'date-fns';
import { supabase } from '../api/supabaseClient';
import { useAuthStore } from '../store/useAuthStore';
import BandPostModal from '../modals/BandPostModal';
import BackFAB from '../components/ui/BackFAB';
import LikeButton from '../components/ui/LikeButton';
import CommentList from '../components/forms/CommentList';

export default function BandDetailScreen({ route, navigation }) {
  const { post } = route.params;
  const currentUser = useAuthStore((state) => state.user);
  const [profile, setProfile] = useState(null);
  const [editModal, setEditModal] = useState(false);

  useEffect(() => {
    fetchAuthorProfile();
  }, []);

  const fetchAuthorProfile = async () => {
    const { data } = await supabase
      .from('users')
      .select('nickname, avatar_url')
      .eq('id', post.user_id)
      .single();
    if (data) setProfile(data);
  };

  const handleDeletePost = async () => {
    Alert.alert('削除確認', 'この投稿を削除しますか？', [
      { text: 'キャンセル' },
      {
        text: '削除',
        style: 'destructive',
        onPress: async () => {
          const { error } = await supabase
            .from('band_posts')
            .delete()
            .eq('id', post.id);
          if (!error) {
            Alert.alert('削除されました');
            navigation.goBack();
          }
        },
      },
    ]);
  };

  const renderTagList = (emoji, label, list = []) => (
    <View>
      <Text>
        {emoji} {label}
      </Text>
      <View>
        {(list?.length > 0 ? list : ['-']).map((item, idx) => (
          <Text key={idx}>
            {item}
          </Text>
        ))}
      </View>
      <View />
    </View>
  );

  const renderAgeRange = () => (
    <View>
      <Text>🎂 募集年齢</Text>
      <Text>
        {post.age_range ? post.age_range.replace('~', '〜') + ' 歳' : '全年齢'}
      </Text>
      <View />
    </View>
  );

  const renderBeginnerOk = () => (
    <View>
      <Text>🐣 初心者OK</Text>
      <View>
        <View />
        <Text>{post.is_beginner_ok ? '' : ''}</Text>
      </View>
      <View />
    </View>
  );

  return (
    <View>
      <ScrollView>
        <View>
          <View>
            <View>
              <Text>
                「{post.region || 'こだわらない'}」{post.title}
              </Text>
              <Text>
                投稿日:{' '}
                {post.created_at
                  ? format(new Date(post.created_at), 'yyyy/MM/dd')
                  : '日付不明'}
              </Text>
            </View>
            <View>
              {profile && (
                <>
                  <Image
                    source={{ uri: profile.avatar_url }}
                  />
                  <Text>{profile.nickname}</Text>
                </>
              )}
            </View>
          </View>
          <View />
          {renderTagList('🎸', 'パート', post.parts)}
          {renderTagList('🎼', 'ジャンル', post.genres)}
          {renderTagList('📅', '活動曜日', post.activity_days)}
          {renderTagList('📍', '方向性', post.directions)}
          {renderTagList('👥', '募集性別', post.gender ? [post.gender] : [])}
          {renderAgeRange()}
          {renderTagList('🔗', 'URL', post.demo_url ? [post.demo_url] : [])}
          {renderBeginnerOk()}
          <View>
            <LikeButton to_user_id={post.user_id} />
            {currentUser.id === post.user_id && (
              <View>
                <TouchableOpacity onPress={() => setEditModal(true)}>
                  <Text>✏️ 編集</Text>
                </TouchableOpacity>
                <TouchableOpacity onPress={handleDeletePost}>
                  <Text>🗑 削除</Text>
                </TouchableOpacity>
              </View>
            )}
          </View>
        </View>
        <CommentList to_user_id={post.user_id} />
      </ScrollView>
      <BackFAB />
      <BandPostModal
        visible={editModal}
        mode="edit"
        initialData={post}
        onClose={() => setEditModal(false)}
        onPostCreated={() => setEditModal(false)}
      />
    </View>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\screens\BandListScreen.js =====
import React, { useEffect, useLayoutEffect, useState } from 'react';
import {
  View,
  Text,
  FlatList,
  TouchableOpacity,
} from 'react-native';
import { supabase } from '../api/supabaseClient';
import { format } from 'date-fns';
import BandPostModal from '../modals/BandPostModal';
import { useAuthStore } from '../store/useAuthStore';
import { useNavigation } from '@react-navigation/native';

export default function BandListScreen() {
  const [posts, setPosts] = useState([]);
  const [showModal, setShowModal] = useState(false);
  const user = useAuthStore((state) => state.user);
  const navigation = useNavigation();

  useEffect(() => {
    fetchPosts();
  }, []);

  const fetchPosts = async () => {
    const { data } = await supabase
      .from('band_posts')
      .select('*')
      .order('created_at', { ascending: false });

    if (data) setPosts(data);
  };

  useLayoutEffect(() => {
    navigation.setOptions({
      headerShown: false,
    });
  }, [navigation]);

  return (
    <View>
      <FlatList
        data={posts}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <TouchableOpacity
            onPress={() => navigation.navigate('BandDetail', { post: item })}
          >
            <Text>{item.title}</Text>
            <Text>
              {item.region}・{format(new Date(item.created_at), 'yyyy/M/d')}
            </Text>
          </TouchableOpacity>
        )}
      />

      <TouchableOpacity onPress={() => setShowModal(true)}>
        <Text>＋</Text>
      </TouchableOpacity>

      <BandPostModal
        visible={showModal}
        onClose={() => setShowModal(false)}
        onPostCreated={fetchPosts}
      />
    </View>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\screens\ChatScreen.js =====
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, TouchableOpacity } from 'react-native';
import { supabase } from '../api/supabaseClient';
import { useAuthStore } from '../store/useAuthStore';

export default function ChatScreen({ navigation }) {
  const user = useAuthStore((state) => state.user);
  const [rooms, setRooms] = useState([]);

  useEffect(() => {
    fetchRooms();
  }, []);

  const fetchRooms = async () => {
    const { data } = await supabase
      .from('private_chat_rooms')
      .select(`
        id,
        user1_id,
        user2_id,
        created_at,
        user1:users!private_chat_rooms_user1_id_fkey(nickname, avatar_url),
        user2:users!private_chat_rooms_user2_id_fkey(nickname, avatar_url)
      `)
      .or(`user1_id.eq.${user.id},user2_id.eq.${user.id}`);
    if (data) setRooms(data);
  };

  const getOtherUser = (room) =>
    room.user1_id === user.id ? room.user2 : room.user1;

  return (
    <View>
      <Text>自分の1:1チャットルーム</Text>
      <FlatList
        data={rooms}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => {
          const other = getOtherUser(item);
          return (
            <TouchableOpacity
              onPress={() => navigation.navigate('PrivateChatRoom', { roomId: item.id, otherUser: other })}
            >
              <Text>{other?.nickname || '-'}</Text>
            </TouchableOpacity>
          );
        }}
        ListEmptyComponent={<Text style={{ textAlign: 'center', color: '#aaa' }}>チャットルームがありません</Text>}
      />
    </View>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\screens\CommunityScreen.js =====
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, TouchableOpacity } from 'react-native';
import { supabase } from '../api/supabaseClient';
import GroupChatRoomModal from '../modals/GroupChatRoomModal';

export default function CommunityScreen({ navigation }) {
  const [rooms, setRooms] = useState([]);
  const [showModal, setShowModal] = useState(false);

  useEffect(() => {
    fetchRooms();
  }, []);

  const fetchRooms = async () => {
    const { data } = await supabase
      .from('group_chat_rooms')
      .select('*')
      .order('created_at', { ascending: false });
    if (data) setRooms(data);
  };

  return (
    <View>
      <Text>グループチャットルーム一覧</Text>
      <FlatList
        data={rooms}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <TouchableOpacity
            onPress={() => navigation.navigate('GroupChatRoom', { roomId: item.id })}
          >
            <Text>{item.name}</Text>
            <Text>
              ({item.is_public ? '公開' : '非公開'}) | {item.max_members}人
            </Text>
            {item.notice ? <Text>お知らせ: {item.notice}</Text> : null}
          </TouchableOpacity>
        )}
        ListEmptyComponent={<Text style={{ textAlign: 'center', color: '#aaa' }}>チャットルームがありません</Text>}
      />
      <TouchableOpacity onPress={() => setShowModal(true)}>
        <Text>＋</Text>
      </TouchableOpacity>
      <GroupChatRoomModal
        visible={showModal}
        onClose={() => setShowModal(false)}
        onCreated={fetchRooms}
      />
    </View>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\screens\GroupChatRoomScreen.js =====
import React, { useEffect, useState, useRef } from 'react';
import { View, Text, TextInput, TouchableOpacity, FlatList, KeyboardAvoidingView, Alert } from 'react-native';
import { supabase } from '../api/supabaseClient';
import { useAuthStore } from '../store/useAuthStore';

export default function GroupChatRoomScreen({ route }) {
  const { roomId } = route.params;
  const user = useAuthStore((state) => state.user);
  const [room, setRoom] = useState({});
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  const [notice, setNotice] = useState('');
  const flatListRef = useRef();

  useEffect(() => {
    fetchRoom();
    fetchMessages();
    const channel = supabase
      .channel('group_chat_messages:' + roomId)
      .on('postgres_changes',
        { event: '*', schema: 'public', table: 'group_chat_messages', filter: `room_id=eq.${roomId}` },
        fetchMessages
      ).subscribe();
    return () => { supabase.removeChannel(channel); }
  }, [roomId]);

  const fetchRoom = async () => {
    const { data } = await supabase
      .from('group_chat_rooms')
      .select('*')
      .eq('id', roomId)
      .single();
    if (data) {
      setRoom(data);
      setNotice(data.notice || '');
    }
  };

  const fetchMessages = async () => {
    const { data } = await supabase
      .from('group_chat_messages')
      .select('*')
      .eq('room_id', roomId)
      .order('created_at', { ascending: true });
    if (data) setMessages(data);
  };

  const sendMessage = async () => {
    if (input.trim()) {
      await supabase.from('group_chat_messages').insert({
        room_id: roomId, sender_id: user.id, content: input,
      });
      setInput('');
      setTimeout(() => flatListRef.current?.scrollToEnd({ animated: true }), 100);
    }
  };

  const isOwner = room.owner_id === user.id;
  const updateNotice = async () => {
    await supabase.from('group_chat_rooms').update({ notice }).eq('id', roomId);
    Alert.alert('お知らせの編集', 'お知らせが更新されました。');
    fetchRoom();
  };

  return (
    <KeyboardAvoidingView behavior="padding">
      <View>
        <Text>{room.name || 'チャットルーム'}</Text>
        <Text>{room.description}</Text>
        <View>
          <Text>お知らせ</Text>
          {isOwner ? (
            <View>
              <TextInput
                value={notice}
                onChangeText={setNotice}
                placeholder="お知らせを入力"
              />
              <TouchableOpacity onPress={updateNotice}>
                <Text>お知らせを編集</Text>
              </TouchableOpacity>
            </View>
          ) : (
            <Text>{room.notice || '(お知らせなし)'}</Text>
          )}
        </View>
        <FlatList
          ref={flatListRef}
          data={messages}
          keyExtractor={item => item.id}
          renderItem={({ item }) => (
            <View style={{
              alignSelf: item.sender_id === user.id ? 'flex-end' : 'flex-start',
            }}>
              <Text>{item.content}</Text>
              <Text style={{ fontSize: 10 }}>{item.created_at?.slice(11,16)}</Text>
            </View>
          )}
        />
        <View style={{ flexDirection: 'row' }}>
          <TextInput
            style={{ flex: 1 }}
            value={input}
            onChangeText={setInput}
            placeholder="メッセージを入力"
          />
          <TouchableOpacity onPress={sendMessage}>
            <Text>送信</Text>
          </TouchableOpacity>
        </View>
      </View>
    </KeyboardAvoidingView>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\screens\PrivateChatRoomScreen.js =====
import React, { useEffect, useState, useRef } from 'react';
import { View, Text, TextInput, TouchableOpacity, FlatList, KeyboardAvoidingView } from 'react-native';
import { supabase } from '../api/supabaseClient';
import { useAuthStore } from '../store/useAuthStore';

export default function PrivateChatRoomScreen({ route }) {
  const { roomId, otherUser } = route.params;
  const user = useAuthStore((state) => state.user);
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  const flatListRef = useRef();

  useEffect(() => {
    fetchMessages();
    const channel = supabase
      .channel('private_chat_messages:'+roomId)
      .on('postgres_changes',
        { event: '*', schema: 'public', table: 'private_chat_messages', filter: `room_id=eq.${roomId}` },
        fetchMessages
      ).subscribe();
    return () => { supabase.removeChannel(channel); }
  }, [roomId]);

  const fetchMessages = async () => {
    const { data } = await supabase
      .from('private_chat_messages')
      .select('*')
      .eq('room_id', roomId)
      .order('created_at', { ascending: true });
    if (data) setMessages(data);
  };

  const sendMessage = async () => {
    if (input.trim()) {
      await supabase.from('private_chat_messages').insert({
        room_id: roomId, sender_id: user.id, content: input,
      });
      setInput('');
      setTimeout(() => flatListRef.current?.scrollToEnd({ animated: true }), 100);
    }
  };

  return (
    <KeyboardAvoidingView behavior="padding">
      <View>
        <Text>{otherUser?.nickname || '相手'}</Text>
        <FlatList
          ref={flatListRef}
          data={messages}
          keyExtractor={item => item.id}
          renderItem={({ item }) => (
            <View style={{
              alignSelf: item.sender_id === user.id ? 'flex-end' : 'flex-start',
            }}>
              <Text>{item.content}</Text>
              <Text style={{ fontSize: 10 }}>{item.created_at?.slice(11,16)}</Text>
            </View>
          )}
        />
        <View style={{ flexDirection: 'row' }}>
          <TextInput
            style={{ flex: 1 }}
            value={input}
            onChangeText={setInput}
            placeholder="メッセージを入力"
          />
          <TouchableOpacity onPress={sendMessage}>
            <Text>送信</Text>
          </TouchableOpacity>
        </View>
      </View>
    </KeyboardAvoidingView>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\screens\SearchResultsScreen.js =====
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  FlatList,
  TouchableOpacity,
} from 'react-native';
import { supabase } from '../api/supabaseClient';
import BackFAB from '../components/ui/BackFAB';
import UserFilterBar from '../components/forms/UserFilterBar';

export default function SearchResultsScreen({ route, navigation }) {
  const { keyword, category } = route.params;
  const [results, setResults] = useState([]);
  const [sortBy, setSortBy] = useState('name');
  const [region, setRegion] = useState('すべて');
  const [minAge, setMinAge] = useState(null);
  const [maxAge, setMaxAge] = useState(null);
  const [partFilter, setPartFilter] = useState(null);

  useEffect(() => {
    fetchResults();
  }, [keyword, category, sortBy, region, minAge, maxAge, partFilter]);

  const fetchResults = async () => {
    let query;
    if (category === 'ユーザー') {
      query = supabase
        .from('users')
        .select('*')
        .ilike('nickname', `%${keyword}%`);
      if (region !== 'すべて') query = query.eq('region', region);
      if (minAge && maxAge)
        query = query
          .gte('birth_year', 2025 - maxAge)
          .lte('birth_year', 2025 - minAge);
      if (partFilter) query = query.contains('parts', [partFilter]);
      if (sortBy === 'likes') query.order('like_count', { ascending: false });
      else query.order('nickname');
    } else {
      const table = category === 'バンド' ? 'band_posts' : 'session_posts';
      query = supabase.from(table).select('*').ilike('title', `%${keyword}%`);
      query.order('created_at', { ascending: false });
    }
    const { data } = await query;
    setResults(data || []);
  };

  const renderItem = ({ item }) => (
    <TouchableOpacity>
      <Text>{item.nickname || item.title}</Text>
    </TouchableOpacity>
  );

  return (
    <View>
      <Text>
        「{keyword}」の{category}検索結果（{results.length}件）
      </Text>
      {category === 'ユーザー' && (
        <UserFilterBar
          sortBy={sortBy}
          setSortBy={setSortBy}
          region={region}
          setRegion={setRegion}
          minAge={minAge}
          maxAge={maxAge}
          setMinAge={setMinAge}
          setMaxAge={setMaxAge}
          partFilter={partFilter}
          setPartFilter={setPartFilter}
        />
      )}
      <FlatList
        data={results}
        keyExtractor={(item) => item.id.toString()}
        renderItem={renderItem}
      />
      <BackFAB onPress={() => navigation.goBack()} />
    </View>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\screens\SessionDetailScreen.js =====
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  Image,
  TouchableOpacity,
  ScrollView,
  Alert,
} from 'react-native';
import { format } from 'date-fns';
import { supabase } from '../api/supabaseClient';
import { useAuthStore } from '../store/useAuthStore';
import SessionPostModal from '../modals/SessionPostModal';
import BackFAB from '../components/ui/BackFAB';
import LikeButton from '../components/ui/LikeButton';
import CommentList from '../components/forms/CommentList';
import UserMiniModal from '../modals/UserMiniModal';

export default function SessionDetailScreen({ route, navigation }) {
  const { post } = route.params;
  const currentUser = useAuthStore((state) => state.user);
  const [profile, setProfile] = useState(null);
  const [authorFull, setAuthorFull] = useState(null);
  const [editModal, setEditModal] = useState(false);
  const [miniModal, setMiniModal] = useState(false);

  useEffect(() => {
    fetchAuthorProfile();
  }, []);

  const fetchAuthorProfile = async () => {
    const { data } = await supabase
      .from('users')
      .select('id, nickname, avatar_url, region, parts')
      .eq('id', post.user_id)
      .single();
    if (data) {
      setProfile({ nickname: data.nickname, avatar_url: data.avatar_url });
      setAuthorFull(data);
    }
  };

  const handleChat = async () => {
    if (!authorFull) return;
    const [user1_id, user2_id] =
      currentUser.id < authorFull.id
        ? [currentUser.id, authorFull.id]
        : [authorFull.id, currentUser.id];
    let { data: rooms } = await supabase
      .from('private_chat_rooms')
      .select('*')
      .eq('user1_id', user1_id)
      .eq('user2_id', user2_id);
    let roomId;
    if (rooms && rooms.length > 0) {
      roomId = rooms[0].id;
    } else {
      const { data, error } = await supabase
        .from('private_chat_rooms')
        .insert([{ user1_id, user2_id }])
        .select();
      roomId = data?.[0]?.id;
    }
    setMiniModal(false);
    if (roomId) {
      navigation.navigate('PrivateChatRoom', { roomId, otherUser: authorFull });
    }
  };

  const handleDeletePost = async () => {
    Alert.alert('削除確認', 'この投稿を削除しますか？', [
      { text: 'キャンセル' },
      {
        text: '削除',
        style: 'destructive',
        onPress: async () => {
          const { error } = await supabase
            .from('session_posts')
            .delete()
            .eq('id', post.id);
          if (!error) {
            Alert.alert('削除されました');
            navigation.goBack();
          }
        },
      },
    ]);
  };

  const renderTagList = (emoji, label, list = []) => (
    <View>
      <Text>
        {emoji} {label}
      </Text>
      <View>
        {(list?.length > 0 ? list : ['-']).map((item, idx) => (
          <Text key={idx}>
            {item}
          </Text>
        ))}
      </View>
      <View />
    </View>
  );

  const renderAgeRange = () => (
    <View>
      <Text>🎂 募集年齢</Text>
      <Text>
        {post.age_range ? post.age_range.replace('~', '〜') + ' 歳' : '全年齢'}
      </Text>
      <View />
    </View>
  );

  const renderBeginnerOk = () => (
    <View>
      <Text>🐣 初心者OK</Text>
      <View>
        <View />
        <Text>{post.is_beginner_ok ? '' : ''}</Text>
      </View>
      <View />
    </View>
  );

  return (
    <View>
      <ScrollView>
        <View>
          <View>
            <View>
              <Text>
                「{post.region || 'こだわらない'}」{post.title}
              </Text>
              <Text>
                投稿日:{' '}
                {post.created_at
                  ? format(new Date(post.created_at), 'yyyy/MM/dd')
                  : '日付不明'}
              </Text>
            </View>
            <View>
              {profile && (
                <>
                  <Image
                    source={{ uri: profile.avatar_url }}
                  />
                  <Text>{profile.nickname}</Text>
                </>
              )}
            </View>
          </View>
          <View />
          {renderTagList('🎸', 'パート', post.parts)}
          {renderTagList('🎼', 'ジャンル', post.genres)}
          {renderTagList('📅', '活動曜日', post.activity_days)}
          {renderTagList('📍', '方向性', post.directions)}
          {renderTagList('👥', '募集性別', post.gender ? [post.gender] : [])}
          {renderAgeRange()}
          {renderTagList('🔗', 'URL', post.demo_url ? [post.demo_url] : [])}
          {renderBeginnerOk()}
          <View>
            <LikeButton to_user_id={post.user_id} />
            {currentUser.id === post.user_id && (
              <View>
                <TouchableOpacity onPress={() => setEditModal(true)}>
                  <Text>✏️ 編集</Text>
                </TouchableOpacity>
                <TouchableOpacity onPress={handleDeletePost}>
                  <Text>🗑 削除</Text>
                </TouchableOpacity>
              </View>
            )}
          </View>
        </View>
        <CommentList to_user_id={post.user_id} />
      </ScrollView>
      <BackFAB />
      <UserMiniModal
        visible={miniModal}
        user={authorFull}
        onClose={() => setMiniModal(false)}
        onViewProfile={() => {
          setMiniModal(false);
          global.openProfileViewModal?.(authorFull);
        }}
        onChat={handleChat}
      />
      <SessionPostModal
        visible={editModal}
        mode="edit"
        initialData={post}
        onClose={() => setEditModal(false)}
        onPostCreated={() => setEditModal(false)}
      />
    </View>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\screens\SessionListScreen.js =====
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  FlatList,
  TouchableOpacity,
} from 'react-native';
import { supabase } from '../api/supabaseClient';
import { format } from 'date-fns';
import SessionPostModal from '../modals/SessionPostModal';
import { useAuthStore } from '../store/useAuthStore';
import { useNavigation } from '@react-navigation/native';

export default function SessionListScreen() {
  const [posts, setPosts] = useState([]);
  const [showModal, setShowModal] = useState(false);
  const user = useAuthStore((state) => state.user);
  const navigation = useNavigation();

  useEffect(() => {
    fetchPosts();
  }, []);

  const fetchPosts = async () => {
    const { data } = await supabase
      .from('session_posts')
      .select('*')
      .order('created_at', { ascending: false });
    if (data) setPosts(data);
  };

  return (
    <View>
      <FlatList
        data={posts}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <TouchableOpacity
            onPress={() => navigation.navigate('SessionDetail', { post: item })}
          >
            <Text>{item.title}</Text>
            <Text>
              {item.region}・{format(new Date(item.created_at), 'yyyy/M/d')}
            </Text>
          </TouchableOpacity>
        )}
      />
      <TouchableOpacity onPress={() => setShowModal(true)}>
        <Text>＋</Text>
      </TouchableOpacity>
      <SessionPostModal
        visible={showModal}
        onClose={() => setShowModal(false)}
        onPostCreated={fetchPosts}
      />
    </View>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\screens\SettingsScreen.js =====
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  Alert,
  ScrollView,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { useAuthStore } from '../store/useAuthStore';
import { supabase } from '../api/supabaseClient';
import OnboardingModal from '../modals/OnboardingModal';
import Button from '../components/ui/Button';
import SectionTitle from '../components/ui/SectionTitle';
import ProfileImage from '../components/ui/ProfileImage';

export default function SettingsScreen() {
  const navigation = useNavigation();
  const user = useAuthStore((state) => state.user);
  const [profile, setProfile] = useState(null);
  const [modalVisible, setModalVisible] = useState(false);
  const [editProfileData, setEditProfileData] = useState({});

  useEffect(() => {
    fetchProfile();
  }, []);

  const fetchProfile = async () => {
    const { data, error } = await supabase
      .from('users')
      .select('*')
      .eq('id', user.id)
      .single();
    if (error) {
      Alert.alert('エラー', 'プロフィールの取得に失敗しました');
    } else {
      setProfile(data);
    }
  };

  const goToViewProfile = () => {
    if (profile) {
      global.openProfileViewModal(profile);
    }
  };

  const goToEditProfile = () => {
    if (profile) {
      setEditProfileData(profile);
      setModalVisible(true);
    }
  };

  const handleLogout = async () => {
    const { error } = await supabase.auth.signOut();
    if (error) {
      Alert.alert('ログアウト失敗', error.message);
    } else {
      Alert.alert('ログアウトしました');
    }
  };

  return (
    <ScrollView>
      <SectionTitle title="プロフィール設定" />

      <OnboardingModal
        visible={modalVisible}
        onClose={async () => {
          setModalVisible(false);
          setTimeout(fetchProfile, 500);
        }}
        initialProfile={editProfileData}
        mode="edit"
      />

      <View>
        <ProfileImage uri={profile?.avatar_url} size={80} />
        <Text>{profile?.nickname || 'ユーザー'}</Text>
        <View>
          <Button
            title="プロフィール確認"
            onPress={goToViewProfile}
            type="ghost"
          />
          <Button
            title="プロフィール変更"
            onPress={goToEditProfile}
            type="ghost"
          />
        </View>
      </View>

      <Button title="広告削除・サポート" />
      <Button title="プライバシー・ポリシー" />
      <Button title="🚪 ログアウト" onPress={handleLogout} />
      <Button title="アカウント削除" />
    </ScrollView>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\screens\SignInScreen.js =====
import React, { useState } from 'react';
import {
  View,
  Text,
  TextInput,
  Alert,
  TouchableOpacity,
  Animated,
} from 'react-native';
import { signIn } from '../api/auth';
import { useAuthStore } from '../store/useAuthStore';
import { supabase } from '../api/supabaseClient';
import Button from '../components/ui/Button';
import SectionTitle from '../components/ui/SectionTitle';

export default function SignInScreen({ navigation }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [fadeAnim] = useState(new Animated.Value(0));

  const handleLogin = async () => {
    const { data, error } = await signIn(email, password);
    if (error) {
      Alert.alert('ログイン失敗', error.message);
      return;
    }

    const user = data.user;
    if (!user) {
      Alert.alert('失敗', 'ユーザー情報が取得できませんでした');
      return;
    }

    const isEmailConfirmed =
      user.email_confirmed || user.email_confirmed_at || false;

    if (!isEmailConfirmed) {
      Alert.alert(
        'メール未確認',
        'メールアドレスの確認が必要です。メールをご確認ください。',
      );
      return;
    }

    useAuthStore.getState().setUser(user);

    const { data: existingUser, error: fetchError } = await supabase
      .from('users')
      .select('*')
      .eq('id', user.id)
      .single();

    if (fetchError) {
      const { error: insertError } = await supabase.from('users').upsert({
        id: user.id,
        email: user.email,
      });

      if (insertError) {
        Alert.alert('プロファイル作成失敗', insertError.message);
        return;
      }

      navigation.replace('Main');
      return;
    }

    navigation.replace('Main');
  };

  React.useEffect(() => {
    Animated.timing(fadeAnim, {
      toValue: 1,
      duration: 500,
      useNativeDriver: true,
    }).start();
  }, []);

  return (
    <Animated.View style={{ opacity: fadeAnim }}>
      <SectionTitle title="ログイン" />

      <Text>メールアドレス</Text>
      <TextInput
        value={email}
        onChangeText={setEmail}
        autoCapitalize="none"
        placeholder="example@email.com"
      />

      <Text>パスワード</Text>
      <TextInput
        value={password}
        onChangeText={setPassword}
        secureTextEntry
        placeholder="••••••••"
      />

      <Button title="ログイン" onPress={handleLogin} />

      <TouchableOpacity onPress={() => navigation.navigate('SignUp')}>
        <Text>アカウントがありませんか？ 新規登録</Text>
      </TouchableOpacity>
    </Animated.View>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\screens\SignUpScreen.js =====
import React, { useState, useRef, useEffect } from 'react';
import {
  Text,
  TextInput,
  Alert,
  TouchableOpacity,
  Animated,
} from 'react-native';
import { signUp } from '../api/auth';
import { supabase } from '../api/supabaseClient';
import { useAuthStore } from '../store/useAuthStore';
import { useNavigation } from '@react-navigation/native';
import SectionTitle from '../components/ui/SectionTitle';
import Button from '../components/ui/Button';

export default function SignUpScreen() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const navigation = useNavigation();
  const fadeAnim = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    Animated.timing(fadeAnim, {
      toValue: 1,
      duration: 800,
      useNativeDriver: true,
    }).start();
  }, []);

  const handleSignUp = async () => {
    const { data, error } = await signUp(email, password);

    if (error) {
      if (error.message.includes('User already registered')) {
        Alert.alert(
          '登録済み',
          'このメールアドレスは既に登録されています。ログインしてください。',
        );
        navigation.replace('SignIn');
        return;
      }
      Alert.alert('登録失敗', error.message);
      return;
    }

    const user = data?.user;
    if (!user || !user.email_confirmed_at) {
      Alert.alert('仮登録完了', '確認メールをご確認ください。');
      navigation.replace('SignIn');
      return;
    }

    useAuthStore.getState().setUser(user);
    const { error: upsertError } = await supabase.from('users').upsert({
      id: user.id,
      email: user.email,
    });

    if (upsertError) {
      Alert.alert('プロフィール保存失敗', upsertError.message);
    } else {
      Alert.alert('ようこそ！', 'アカウントが作成されました。');
      navigation.replace('Main');
    }
  };

  return (
    <Animated.View style={{ opacity: fadeAnim }}>
      <SectionTitle title="新規登録" />

      <Text>メールアドレス</Text>
      <TextInput
        value={email}
        onChangeText={setEmail}
        autoCapitalize="none"
        placeholder="email@example.com"
        keyboardType="email-address"
      />

      <Text>パスワード</Text>
      <TextInput
        value={password}
        onChangeText={setPassword}
        secureTextEntry
        placeholder="••••••••"
      />

      <Button title="新規登録" onPress={handleSignUp} />

      <TouchableOpacity onPress={() => navigation.navigate('SignIn')}>
        <Text>アカウントをお持ちですか？ ログイン</Text>
      </TouchableOpacity>
    </Animated.View>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\screens\StudioScreen.js =====
import React from 'react';
import { View, Text } from 'react-native';

export default function StudioScreen() {
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Text>Studio</Text>
    </View>
  );
}


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\services\adService.js =====



===== C:\Users\so0002\Downloads\bandhand\bandhand\src\services\studioService.js =====



===== C:\Users\so0002\Downloads\bandhand\bandhand\src\services\twitterService.js =====



===== C:\Users\so0002\Downloads\bandhand\bandhand\src\store\useAuthStore.js =====
// src/store/useAuthStore.js
import { create } from 'zustand';

export const useAuthStore = create((set) => ({
  user: null,
  setUser: (user) => set({ user }),
  clearUser: () => set({ user: null }),
}));


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\utils\formatter.js =====


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\utils\notifications.js =====
// src/utils/notifications.js
export const getNotificationMessage = (type, nickname = '誰か') => {
  switch (type) {
    case 'like':
      return `${nickname}さんがあなたに「いいね」しました！`;
    case 'comment':
      return `${nickname}さんがコメントを残しました`;
    default:
      return '新しい通知があります';
  }
};


===== C:\Users\so0002\Downloads\bandhand\bandhand\src\utils\validate.js =====


